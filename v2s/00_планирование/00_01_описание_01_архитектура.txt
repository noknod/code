1. front-end (слой отображения):
   сервер(а), создающие HTML-страницы и отдающие клиенту;

2. кэш (слой кэширования):
   хранилище данных в памяти сервера(ов) слоя ?отображения или логики? 
для часто используемых данных;

3. back-end (слой логики):  
   сервер(а), осуществляющие подбор и обработку данных для слоя отображения 
с целью дальнейшей отдачи содержимого клиенту;

4. постоянное хранение данных (слой хранения данных):
   4.1 структурированные данные: управление учётными записями пользователей и 
доступом к содержимому;
   4.2 неструктурированные данные: сообщения пользователей и другое содержимое;
   базы данных для слоя логики;

5. аналитика (слой аналитики):
   подсистема предсказания поведения клиента и предложения рекламы на основе 
технологий Spark по методологии RTB (Real-Time Bidding);

6. управление всей системой (слой администрирования): 
   подсистемы конфигурирования, запуска и отслеживания работы приложений и 
серверов, подсистемы логирования и сбора статистики.

- - -

1. front-end (слой отображения):

Задача: Используя шаблоны (для ускорения разработки и придания страницам, 
имеющим одно смысловое наполнение, одинаковое внешний вид), создавать и 
отдавать клиенту HTML-страницы по данным, которые возвращает слой логики.


Технологии:

Вариант 1: Node.js + шаблонизатор стэка MEAN (http://mean.io/).

Вариант 2_Scala: Play! Spray (сервер на Java NIO/Akka) + шаблонизатор Scala templates.

Вариант 3: Node.js + шаблонизатор Swig.


Поток информации (порядок обмена сообщениями):

- приём сообщений внешнего мира по протоколу HTTP;

- со слоем логики:
    - передача сообщений от внешнего мира по протоколу HTTP;
    - получение ответа от слоя логики в формате JSON;

- отправка ответа внешнему миру по протоколу HTTP.

- - -

2. кэш (слой кэширования):


Технологии:

Вариант 1: Redis

- - -

3. back-end (слой логики):  


Технологии:

Вариант 1_Scala: Play! 2.1 Framework (сервер Netty на Java NIO/Akka).

Вариант 2_Python: Flask



https://ru.wikipedia.org/wiki/Scala_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Использование:
В апреле 2009 года Twitter объявил что перевёл значительную часть своего серверного кода с Ruby на Scala и собирается перевести оставшийся

use actors on application layer but what would be better for Web front-end -
Netty or Spray-io

http://eax.me/redis/

http://db-engines.com/en/system/Memcached%3BRedis

строить композицию страниц на языке JAVA, используя собственные GUI фабрики (оформление текста, списки, таблицы, портлеты).
• Композиция страниц состоит из независимых блоков (обычно портлетов), что позволяет обновлять информацию на экране частями, используя AJAX запросы. Такой подход к навигации позволяет избавиться от постоянных перезагрузок страницы, тем самым важные функции сайта (Сообщения, Обсуждения и Оповещения) всегда доступны пользователю. Без javascript страница полностью работоспособна, кроме функциональностей, написанных на GWT — при переходах по ссылкам она просто полностью перерисовывается.
• Функциональные компоненты как Сообщения, Обсуждения и Оповещения, а также все динамичные части (шорткат меню, фотометки, сортировка фотографий, ротирование подарочков) написаны, используя фреймворк Google Web Toolkit.


Scala стала популярна в машинном обучении после того, как появился Apache Spark и используется, когда нужно обучаться на больших выборках (хотя также есть Python и чистая Java). Тут наверное имеет смысл перечислить все преимущества спарка — но это уже, наверное, будет отдельная статья) Основная идея такая: на Scala пишут код, когда нужно обучаться на огромных выборках, или делать online-обучение или real-time аналитику (для этого используется Spark Streaming или Apache Storm — у них одна принципиальная разница, об этом также наверное расскажу подробнее позже). Проблема также в том, что в полноценной коммерческой эксплуатации Spark пока еще сырой, как следствие — довольно мало организаций его используют